name: .NET Core CI/CD

on:
  push:
    branches:
      - master
      - main

env:
  AZURE_CONTAINER_REGISTRY: your-acr-name # Cambia esto por tu ACR name
  IMAGE_NAME: finalproject-web
  RESOURCE_GROUP: your-resource-group # Cambia esto por tu resource group

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      BUILD_CONFIG: Release
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    permissions:
      checks: write
      pull-requests: write

    steps:
    - uses: actions/checkout@v5
      name: Checkout
      with:
        # Disabling shallow clones is recommended for improving the relevancy of reporting
        fetch-depth: 0

    - name: Setup .NET Core
      uses: actions/setup-dotnet@v5
      env:
        DOTNET_VERSION: 9.x
      with:
        global-json-file: global.json
        dotnet-version: ${{ env.DOTNET_VERSION }}
        # cache: true
        # cache-dependency-path: "**/packages.lock.json"
    
    - name: .NET Restore
      run:  dotnet restore

    - name: Install Tools
      env:
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      run: | 
          dotnet tool install --global dotnet-sonarscanner
          dotnet tool install --global dotnet-coverage
          dotnet sonarscanner begin /o:"$SONAR_ORGANIZATION" /k:"$SONAR_PROJECT_KEY" /d:sonar.token="$SONAR_TOKEN" /d:sonar.cs.vscoveragexml.reportsPaths=coverage.xml
    
    - name: .NET Build
      run: dotnet build --configuration $BUILD_CONFIG --no-restore
    
    - name: .NET Test with Coverage
      run: dotnet test --configuration $BUILD_CONFIG --no-build --logger trx --collect:"XPlat Code Coverage" 
    
    - name: Collect Data
      run: dotnet-coverage collect "dotnet test" -f xml -o "coverage.xml"

    - name: SonarQube End
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: dotnet sonarscanner end /d:sonar.token="$SONAR_TOKEN"

    - name: Combine Coverage Reports # This is because one report is produced per project, and we want one result for all of them.
      uses: danielpalme/ReportGenerator-GitHub-Action@5
      with:
        reports: "**/*.cobertura.xml" # REQUIRED # The coverage reports that should be parsed (separated by semicolon). Globbing is supported.
        targetdir: "${{ github.workspace }}" # REQUIRED # The directory where the generated report should be saved.
        reporttypes: "Cobertura" # The output formats and scope (separated by semicolon) Values: Badges, Clover, Cobertura, CsvSummary, Html, Html_Dark, Html_Light, Html_BlueRed, HtmlChart, HtmlInline, HtmlInline_AzurePipelines, HtmlInline_AzurePipelines_Dark, HtmlInline_AzurePipelines_Light, HtmlSummary, JsonSummary, Latex, LatexSummary, lcov, MarkdownSummary, MarkdownSummaryGithub, MarkdownDeltaSummary, MHtml, PngChart, SonarQube, TeamCitySummary, TextSummary, TextDeltaSummary, Xml, XmlSummary
        verbosity: "Info" # The verbosity level of the log messages. Values: Verbose, Info, Warning, Error, Off
        title: "Code Coverage" # Optional title.
        tag: "${{ github.run_number }}_${{ github.run_id }}" # Optional tag or build version.
        customSettings: "" # Optional custom settings (separated by semicolon). See: https://github.com/danielpalme/ReportGenerator/wiki/Settings.
        toolpath: "reportgeneratortool" # Default directory for installing the dotnet tool.
    
    - name: Upload Combined Coverage XML
      uses: actions/upload-artifact@v5
      with:
        name: coverage
        path: ${{ github.workspace }}/Cobertura.xml
        retention-days: 5
        
    - name: Publish Code Coverage Report
      uses: irongut/CodeCoverageSummary@v1.3.0
      with:
        filename: "Cobertura.xml"
        badge: true
        fail_below_min: false # just informative for now
        format: markdown
        hide_branch_rate: false
        hide_complexity: false
        indicators: true
        output: both
        thresholds: "10 30"

    - name: Upload Coverage Files
      run: cat code-coverage-results.md >> $GITHUB_STEP_SUMMARY

    - name: Test Report
      uses: dorny/test-reporter@v2
      if: always()
      with:
        name: Test Results
        #report-title: Test Results
        path: "**/*.trx"
        reporter: dotnet-trx
        #only-summary: true
        use-actions-summary: true
    
    - name: Publish Site
      working-directory: src/Web
      run: dotnet publish -c $BUILD_CONFIG --no-restore -o ../Publish
        
    - name: Upload Artifact
      uses: actions/upload-artifact@v5
      with:
        name: web_site
        path: ./src/Publish

  build-and-push-docker:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    steps:
    - uses: actions/checkout@v5
      name: Checkout
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Azure
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: Log in to Azure Container Registry
      run: |
        az acr login --name ${{ env.AZURE_CONTAINER_REGISTRY }}
    
    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=registry,ref=${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:buildcache
        cache-to: type=registry,ref=${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:buildcache,mode=max

    - name: Scan Docker image for vulnerabilities with Trivy
      uses: aquasecurity/trivy-action@v0.13.0
      with:
        image-ref: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:latest
        format: 'table'
        exit-code: '0' # Cambia a '1' si quieres que falle el pipeline ante vulnerabilidades
        output: 'trivy-report.txt'

    - name: Upload Trivy scan report
      uses: actions/upload-artifact@v5
      with:
        name: trivy-report
        path: trivy-report.txt

  deploy:
      needs: [build, build-and-push-docker]
      runs-on: ubuntu-latest
      steps:
      - name: Download Site
        uses: actions/download-artifact@v6
        with:
          name: web_site
          path: web_site
      
      # Opcional: Deploy del contenedor a Azure Container Instances o App Service
      # - name: Deploy to Azure Container Instances
      #   uses: azure/aci-deploy@v1
      #   with:
      #     resource-group: ${{ env.RESOURCE_GROUP }}
      #     dns-name-label: finalproject-${{ github.run_number }}
      #     image: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:latest
      #     registry-login-server: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io
      #     name: finalproject-container
      #     location: 'eastus'
